import torch
import torch.nn as nn
from ultralytics import YOLO
from torchvision import models
import os
import shutil

# SimCLR Backbone 정의
class SimCLR(nn.Module):
    def __init__(self, base_model, out_dim):
        super(SimCLR, self).__init__()
        self.encoder = base_model
        self.projector = nn.Sequential(
            nn.Linear(512, 256),
            nn.ReLU(),
            nn.Linear(256, out_dim)
        )

    def forward(self, x):
        h = self.encoder(x)
        z = self.projector(h)
        return h, z

# YOLO와 SimCLR을 결합한 모델 정의
class YOLOWithSimCLR(nn.Module):
    def __init__(self, yolo_model, simclr):
        super(YOLOWithSimCLR, self).__init__()
        self.yolo = yolo_model
        self.simclr = simclr

    def forward(self, x):
        _, z = self.simclr(x)  # SimCLR에서 특징 추출
        return self.yolo.model(z)  # YOLO 모델에 전달하여 예측 수행
    
    def train_yolo_with_simclr(self, data_path, output_dir, epochs_step1=50, epochs_step2=50, batch_size=16):
        # Step 1 학습
        print("Starting Step 1 Training...")
        self.yolo.train(
            data=data_path,
            epochs=epochs_step1,
            imgsz=640,
            batch=batch_size,  # 배치 크기를 줄여 메모리 사용량 감소
            lr0=0.001,
            device='cuda',
            hsv_h=0.015,
            hsv_s=0.7,
            hsv_v=0.4,
            flipud=0.5,
            fliplr=0.5,
            translate=0.05,  # 더 작은 값으로 설정
            scale=0.4,       # 더 작은 값으로 설정
            shear=0.1,       # 더 작은 값으로 설정
            perspective=0.05,  # 더 작은 값으로 설정,
            mosaic=1.0,
            mixup=0.2,
            copy_paste=0.1,
            amp=False  # Automatic Mixed Precision 비활성화
        )
        
        # Step 1 학습 완료 후 중간 모델 저장
        model_save_path_step1 = os.path.join(output_dir, 'SimCLR_YOLO_step1_model.pt')
        torch.save(self.state_dict(), model_save_path_step1)
        print(f"Step 1 model saved to {model_save_path_step1}")

        # Step 2 학습
        print("Starting Step 2 Fine-tuning...")
        self.yolo.train(
            data=data_path,
            epochs=epochs_step2,
            imgsz=640,
            batch=batch_size,  # 배치 크기를 줄여 메모리 사용량 감소
            lr0=0.0001,  # Fine-tuning 학습률
            device='cuda',
            hsv_h=0.015,
            hsv_s=0.7,
            hsv_v=0.4,
            flipud=0.5,
            fliplr=0.5,
            translate=0.05,  # 더 작은 값으로 설정
            scale=0.4,       # 더 작은 값으로 설정
            shear=0.1,       # 더 작은 값으로 설정
            perspective=0.05,  # 더 작은 값으로 설정,
            mosaic=1.0,
            mixup=0.2,
            copy_paste=0.1,
            amp=False
        )

    def predict(self, *args, **kwargs):
        return self.yolo.predict(*args, **kwargs)

# YOLO 및 SimCLR 초기화 함수
def initialize_yolo_with_simclr():
    yolo_model = YOLO('/home/jovyan/yolo11obb/yolo11m-obb.pt')
    resnet_weights_path = '/home/jovyan/resnet_pretrain/resnet50.pth'
    resnet = models.resnet50(pretrained=False)
    resnet.load_state_dict(torch.load(resnet_weights_path))
    resnet.fc = nn.Identity()
    simclr_model = SimCLR(base_model=resnet, out_dim=128)
    combined_model = YOLOWithSimCLR(yolo_model, simclr_model)
    return combined_model

# 모델 로드 함수
def load_combined_model(model_path, pt_path, num_classes=6):
    # .pt 파일을 사용하여 YOLO 모델 초기화
    yolo_model = YOLO(pt_path)
    
    # 모델의 클래스 수를 맞춰 마지막 레이어 수정
    yolo_model.model.model[-1] = nn.Conv2d(256, num_classes, kernel_size=1)
    
    # SimCLR 모델 정의
    resnet = models.resnet50(pretrained=False)
    resnet.fc = nn.Identity()
    simclr_model = SimCLR(base_model=resnet, out_dim=128)
    
    # YOLO + SimCLR 결합 모델 생성
    model = YOLOWithSimCLR(yolo_model, simclr_model)
    
    # YOLOWithSimCLR 전체 가중치 로드
    state_dict = torch.load(model_path)
    model.load_state_dict(state_dict, strict=False)
    
    model.eval()  # 평가 모드 전환
    return model

# 테스트 함수
def test_model(model, test_image_dir, output_dir, yaml_path):
    # 출력 디렉토리 초기화
    if os.path.exists(output_dir):
        shutil.rmtree(output_dir)
    os.makedirs(output_dir, exist_ok=True)

    # 예측 및 결과 저장
    results = model.predict(
        source=test_image_dir,   # 테스트할 이미지 폴더 경로
        save=True,               # 결과 이미지를 저장
        project=output_dir,      # 저장할 기본 디렉토리
        name="2STEP_SimCLR_YOLO_results",
        data=yaml_path           # 데이터셋 설정 파일 (.yaml) 경로
    )
    print(f"Test results saved to: {os.path.join(output_dir, '2STEP_SimCLR_YOLO_results')}")

# 경로 설정
output_dir = '/home/jovyan/data-vol-1/Result/2STEP_SimCLR_YOLO_b8'
dataset_yaml_path = '/home/jovyan/data-vol-1/Y_T_Data/new_obb.yaml'  # 데이터셋 설정 YAML 파일 경로
model_pt_path = '/home/jovyan/yolo11obb/yolo11m-obb.pt'         # YOLO 모델 가중치 파일 (.pt)
combined_model_path = os.path.join(output_dir, '2STEP_SimCLR_YOLO_b8.pt')
test_image_dir = '/home/jovyan/test_image2'
num_classes = 6  # 데이터셋 클래스 수와 일치하도록 설정

# YOLOWithSimCLR 모델 초기화
model = initialize_yolo_with_simclr()

# Step 1, Step 2 통합 학습 실행 (배치 크기 줄임)
model.train_yolo_with_simclr(dataset_yaml_path, output_dir, batch_size=16)

# 최종 모델 저장
torch.save(model.state_dict(), combined_model_path)
print(f"Final model saved to {combined_model_path}")

# 테스트 실행
test_model(model, test_image_dir, output_dir, dataset_yaml_path)
