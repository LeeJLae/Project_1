import torch
import torch.nn as nn
import torch.optim as optim
from ultralytics import YOLO
from torchvision import models
import os

# SimCLR Backbone 정의
class SimCLR(nn.Module):
    def __init__(self, base_model, out_dim):
        super(SimCLR, self).__init__()
        self.encoder = base_model
        self.projector = nn.Sequential(
            nn.Linear(512, 256),  # ResNet의 출력 채널 크기에 맞춰서 설정
            nn.ReLU(),
            nn.Linear(256, out_dim)
        )

    def forward(self, x):
        h = self.encoder(x)
        z = self.projector(h)
        return h, z

# 로컬에서 ResNet50 사전 학습된 가중치 로드
def load_pretrained_resnet(weights_path):
    resnet = models.resnet50(pretrained=False)  # pretrained=False로 설정
    resnet.load_state_dict(torch.load(weights_path))  # 로컬 가중치 파일 로드
    resnet.fc = nn.Identity()  # SimCLR에서는 최종 fully connected 레이어 제거
    return resnet

# YOLO 모델에 SimCLR 인코더 추가
class YOLOWithSimCLR(nn.Module):
    def __init__(self, yolo_model, simclr):
        super(YOLOWithSimCLR, self).__init__()
        self.yolo = yolo_model
        self.simclr = simclr

    def forward(self, x):
        # SimCLR에서 인코딩한 특징을 사용하여 YOLO 네트워크에 전달
        _, z = self.simclr(x)
        return self.yolo(z)

# Contrastive Loss (SimCLR에서 사용하는 NT-Xent Loss)
class ContrastiveLoss(nn.Module):
    def __init__(self, temperature=0.5):
        super(ContrastiveLoss, self).__init__()
        self.temperature = temperature
        self.criterion = nn.CrossEntropyLoss()

    def forward(self, z_i, z_j):
        batch_size = z_i.size(0)
        z = torch.cat((z_i, z_j), dim=0)
        sim_matrix = torch.matmul(z, z.T) / self.temperature
        sim_i_j = torch.diag(sim_matrix, batch_size)
        sim_j_i = torch.diag(sim_matrix, -batch_size)
        positives = torch.cat((sim_i_j, sim_j_i), dim=0)
        labels = torch.arange(batch_size)
        return self.criterion(positives, labels)

# YOLO 모델 로드
yolo_model = YOLO('/home/jovyan/yolo11obb/yolo11m-obb.pt')

# 로컬에서 ResNet50 가중치 파일 로드
resnet_weights_path = '/home/jovyan/resnet_pretrain/resnet50.pth'  # 로컬 경로 지정
resnet = load_pretrained_resnet(resnet_weights_path)

# SimCLR 모델 정의 (ResNet 백본 사용)
simclr_model = SimCLR(base_model=resnet, out_dim=128)

# YOLO 모델과 SimCLR을 합친 모델 정의
model = YOLOWithSimCLR(yolo_model.model, simclr_model)

# 학습에 사용할 데이터셋 경로를 정의한 .yaml 파일 경로
train_data = '/home/jovyan/data-vol-1/Y_T_Data/new_obb.yaml'

# 학습 결과를 저장할 디렉토리 생성
output_dir = '/home/jovyan/data-vol-1/Result/SimCLR_YOLO'
os.makedirs(output_dir, exist_ok=True)

# Optimizer 설정
optimizer = optim.Adam(model.parameters(), lr=0.001)
contrastive_loss_fn = ContrastiveLoss()

# 1단계 학습 (Contrastive + YOLO 학습)
def train_contrastive_yolo(model, epochs):
    for epoch in range(epochs):
        model.train()
        running_loss = 0.0

        # YOLO train 함수 사용
        model.yolo.train(
            data=train_data,
            epochs=1,               # 한 번에 1 epoch씩 학습
            imgsz=640,
            batch=16,
            lr0=0.001,              # 첫 번째 학습률
            device='cuda',
            amp=False,
            patience=20,
            val=False,
            hsv_h=0.015,            # 색상 증강
            hsv_s=0.7,              # 채도 증강
            hsv_v=0.4,              # 밝기 증강
            flipud=0.5,             # 수직 반전
            fliplr=0.5,             # 수평 반전
            translate=0.1,          # 평행 이동
            scale=0.5,              # 크기 조정
            shear=0.2,              # 기울이기
            perspective=0.1,        # 투시 왜곡
            mosaic=1.0,             # 모자이크 증강
            copy_paste=1.0          # Copy-Paste 증강
        )
        print(f'Epoch [{epoch + 1}/{epochs}] 완료')

# 1단계 학습 실행
train_contrastive_yolo(model, epochs=1)

# 1단계 학습된 모델 저장
model_save_path = os.path.join(output_dir, 'SimCLR_YOLO_model.pt')
torch.save(model.state_dict(), model_save_path)

# 2단계 학습에서 1단계 학습된 SimCLR_YOLO 모델 로드
simclr_yolo_model_path = os.path.join(output_dir, 'SimCLR_YOLO_model.pt')
model.load_state_dict(torch.load(simclr_yolo_model_path))  # SimCLR_YOLO 가중치 로드

# 2단계 YOLO Fine-tuning 학습 (학습된 SimCLR 인코더를 사용)
def train_finetuning_yolo(model, epochs):
    optimizer = optim.Adam(model.parameters(), lr=0.0001)  # Fine-tuning에서 낮은 학습률 사용
    for epoch in range(epochs):
        model.train()

        # YOLO Fine-tuning 함수 사용
        model.yolo.train(
            data=train_data,
            epochs=1,               # 한 번에 1 epoch씩 학습
            imgsz=640,
            batch=16,
            lr0=0.0001,             # 두 번째 학습률 (Fine-tuning)
            device='cuda',
            amp=False,
            patience=20,
            val=False,
            hsv_h=0.015,            # 색상 증강
            hsv_s=0.7,              # 채도 증강
            hsv_v=0.4,              # 밝기 증강
            flipud=0.5,             # 수직 반전
            fliplr=0.5,             # 수평 반전
            translate=0.1,          # 평행 이동
            scale=0.5,              # 크기 조정
            shear=0.2,              # 기울이기
            perspective=0.1,        # 투시 왜곡
            mosaic=1.0,             # 모자이크 증강
            copy_paste=1.0          # Copy-Paste 증강
        )
        print(f'Epoch [{epoch + 1}/{epochs}] Fine-tuning 완료')

# 2단계 Fine-tuning 학습 실행
train_finetuning_yolo(model, epochs=1)

# 테스트 이미지 경로 설정
test_image_dir = '/home/jovyan/test_image2'

# 모델 평가 함수
def test_model():
    # model.predict 사용하여 테스트 수행 및 결과 저장
    results = model.predict(
        source=test_image_dir,  # 테스트할 이미지 폴더 경로
        save=True,              # 결과 이미지를 저장
        project=output_dir,     # 저장할 기본 디렉토리
        name="SimCLR_YOLO_results"     # 결과를 저장할 하위 폴더 이름
    )
    print(f"Test results saved to: {os.path.join(output_dir, 'SimCLR_YOLO_results')}")

# 테스트 실행
test_model()
