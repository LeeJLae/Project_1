
##############################################################################
## 1. 위치 기반 손실 함수 가중치 설정 -> 좌측 하단 또는 하단
## 2. 위치 히트맵 적용
##############################################################################


from ultralytics import YOLO
import os
from shapely.geometry import Polygon
import torch

# YOLO 모델 로드
model = YOLO('/home/jovyan/yolo11obb/yolo11m-obb.pt')

# 학습에 사용할 데이터셋 경로를 정의한 .yaml 파일 경로
train_data = '/home/jovyan/data-vol-1/Y_T_Data/YOLO_WB.yaml'

# 학습 결과를 저장할 디렉토리 생성
output_dir = '/home/jovyan/data-vol-1/Result/YOLO/1STEP_yolov11m'
os.makedirs(output_dir, exist_ok=True)

# IoU 계산 함수
def calculate_iou(box1, box2):
    poly1 = Polygon([(box1[i], box1[i+1]) for i in range(0, len(box1), 2)])
    poly2 = Polygon([(box2[i], box2[i+1]) for i in range(0, len(box2), 2)])
    if not poly1.is_valid or not poly2.is_valid:
        return 0.0
    intersection = poly1.intersection(poly2).area
    union = poly1.union(poly2).area
    return intersection / union if union > 0 else 0

# 정답 바운딩 박스를 읽어오는 함수
def load_ground_truth_boxes(label_folder, image_name):
    label_path = os.path.join(label_folder, os.path.splitext(image_name)[0] + '.txt')
    boxes = []
    if os.path.exists(label_path):
        with open(label_path, 'r') as f:
            for line in f.readlines():
                _, *coords = map(float, line.strip().split())
                boxes.append(coords)
    else:
        print(f"Warning: Ground truth file {label_path} not found.")
    return boxes

# 특정 위치에 대한 가중치를 높이기 위한 커스텀 손실 함수 정의
def custom_loss_function(predictions, targets):
    loss = model.loss_function(predictions, targets)
    
    # 특정 클래스에 대한 위치 기반 가중치 부여 (예: 클래스 ID가 0번인 경우)
    for pred, target in zip(predictions, targets):
        class_id = target[0].item()
        if class_id == 0:  # 특정 클래스 ID (0번)
            x, y = pred[0][0], pred[0][1]  # 예측 바운딩 박스의 중심 좌표
            if x < 0.3 and y > 0.7:  # 좌측 하단 또는 하단 부분에 위치하는 경우
                loss += 2.0 * loss  # 가중치를 더 높여서 손실을 증가시킴
    return loss

# 위치 기반 히트맵 생성 함수
def generate_position_heatmap(image_size):
    heatmap = torch.zeros((image_size, image_size))
    for i in range(image_size):
        for j in range(image_size):
            if i > image_size * 0.7 and j < image_size * 0.3:
                heatmap[i, j] = 1.0  # 하단 및 좌측 하단에 1.0 값을 부여
    return heatmap

# 학습 실행
model.train(
    data=train_data,
    epochs=50,
    imgsz=640,
    batch=16,
    lr0=0.001,
    device='cuda',
    amp=False,
    val=False,
    custom_loss=custom_loss_function  # 커스텀 손실 함수 적용
)

# 히트맵을 이미지에 추가하기 위한 함수 정의
def apply_heatmap_to_images(image_folder, heatmap):
    for image_file in os.listdir(image_folder):
        image_path = os.path.join(image_folder, image_file)
        image = torch.load(image_path)
        image += heatmap  # 히트맵을 이미지에 추가하여 특정 위치에 대한 민감도 증가
        torch.save(image, image_path)

# 히트맵 생성 및 적용
heatmap = generate_position_heatmap(640)
apply_heatmap_to_images('/home/jovyan/data-vol-1/dataset/train/images', heatmap)

# 학습된 모델 저장
model.save(os.path.join(output_dir, '1STEP_yolov11m.pt'))

# 테스트 이미지 및 정답 레이블 폴더 경로 설정
test_image_folder = '/home/jovyan/data-vol-1/dataset/test/images'
label_folder = '/home/jovyan/data-vol-1/dataset/test/labels'

# 모델 평가 함수
def test_model():
    results_folder = os.path.join(output_dir, '1STEP_YOLO_result')
    os.makedirs(results_folder, exist_ok=True)
    
    results = model.predict(
        source=test_image_folder,
        save=True,
        project=output_dir,
        name="1STEP_YOLO_result"
    )
    print(f"Test results saved to: {results_folder}")
    
    # IoU 결과 저장할 파일 경로 설정
    iou_results_path = os.path.join(results_folder, 'iou_results.txt')
    with open(iou_results_path, 'w') as f:
        for result in results:
            image_name = os.path.basename(result.path)
            ground_truths = load_ground_truth_boxes(label_folder, image_name)
            predictions = result.boxes.xyxy if result.boxes is not None else []
            
            # IoU 계산 및 저장
            for gt_box, pred_box in zip(ground_truths, predictions):
                iou = calculate_iou(gt_box, pred_box.tolist())
                f.write(f"IoU for {result.path}: {iou:.4f}\n")
    
    print(f"IoU results saved to: {iou_results_path}")

# 테스트 실행
test_model()
