from ultralytics import YOLO
import os
import cv2
import numpy as np
from scipy.ndimage import rotate

# 절대 경로로 WEIGHTS_PATH 정의
WEIGHTS_PATH = "/home/jovyan/data-vol-1/Result/YOLO/2Step_yolov11m/2Step_2nd.pt"

# 수평 맞춤을 위한 회전 각도 계산
def calculate_horizontal_rotation(obb_points):
    bottom_left = obb_points[0]
    bottom_right = obb_points[1]

    obb_angle = np.degrees(np.arctan2(bottom_right[1] - bottom_left[1], bottom_right[0] - bottom_left[0]))

    if obb_angle < -45:
        obb_angle += 90
    elif obb_angle > 45:
        obb_angle -= 90
        
    return obb_angle

# 중앙 기준으로 Scipy의 rotate 함수를 사용해 이미지 회전
def rotate_image_scipy(image, angle):
    rotated_image = rotate(image, angle, reshape=False)
    return rotated_image

# 모델 테스트 함수
def test_model():
    test_image_folder = '/home/jovyan/data-vol-1/dataset/test/images_test'
    output_dir = '/home/jovyan/data-vol-1/Result/DataPre/mode_1_rotation/Rotation_WB'
     
    results_folder = os.path.join(output_dir, 'Result')
    os.makedirs(results_folder, exist_ok=True)

    model = YOLO(WEIGHTS_PATH)

    results = model.predict(
        source=test_image_folder,
        save=True,
        project=results_folder,
        name="Result"
    )

    bbox_results_path = os.path.join(results_folder, 'bounding_boxes.txt')
    with open(bbox_results_path, 'w') as f:
        for result in results:
            image_name = os.path.basename(result.path)
            f.write(f"Image: {image_name}")

            # 이미지와 동일한 이름의 txt 파일 로드
            txt_file_path = os.path.join(test_image_folder, f"{os.path.splitext(image_name)[0]}.txt")
            class_1_text = None
            if os.path.exists(txt_file_path):
                with open(txt_file_path, 'r') as txt_file:
                    for line in txt_file:
                        class_id, x, y, w, h = line.strip().split()
                        if int(class_id) == 1:  # 클래스 1 텍스트 처리
                            class_1_text = f"Class 1 Text: {x} nm"
                            f.write(f" ({class_1_text})")  # 이미지 제목 옆에 기록
                        elif int(class_id) == 0:  # 클래스 0 b-box 회전 적용
                            class_0_bbox = np.array([[float(x), float(y)],
                                                     [float(x) + float(w), float(y)],
                                                     [float(x) + float(w), float(y) + float(h)],
                                                     [float(x), float(y) + float(h)]])
            f.write("\n")

            image = cv2.imread(result.path)
            original_image_height, original_image_width = image.shape[:2]

            if result.obb is not None:
                class_ids = result.obb.cls
                obb_coordinates = result.obb.xyxyxyxy
                original_bbox_area_sum = 0
                rotated_bbox_area_sum = 0

                for i in range(len(class_ids)):
                    cls = int(class_ids[i].item())
                    if cls in [1, 5]:
                        points = obb_coordinates[i].cpu().numpy()
                        original_bbox_area = cv2.contourArea(points)
                        original_bbox_area_sum += original_bbox_area
                        rotation_angle = calculate_horizontal_rotation(points)
                        rotated_image = rotate_image_scipy(image, rotation_angle)
                        rotated_image_height, rotated_image_width = rotated_image.shape[:2]
                        rotated_bbox_area = original_bbox_area
                        rotated_bbox_area_sum += rotated_bbox_area
                        output_image_path = os.path.join(results_folder, f"rotated_horizontal_{image_name}")
                        cv2.imwrite(output_image_path, rotated_image)
                        points_str = ', '.join([f'({points[j][0]}, {points[j][1]})' for j in range(len(points))])
                        f.write(f'Class: {cls}, OBB Points: {points_str}, Rotation Angle: {rotation_angle:.2f} degrees\n')

                # 클래스 0 b-box 회전 적용하여 기록
                if class_0_bbox is not None:
                    class_0_rotation_angle = calculate_horizontal_rotation(class_0_bbox)
                    rotated_class_0_bbox = np.dot(class_0_bbox - np.mean(class_0_bbox, axis=0),
                                                  [[np.cos(np.radians(class_0_rotation_angle)),
                                                    -np.sin(np.radians(class_0_rotation_angle))],
                                                   [np.sin(np.radians(class_0_rotation_angle)),
                                                    np.cos(np.radians(class_0_rotation_angle))]]) + np.mean(class_0_bbox, axis=0)
                    rotated_bbox_str = ', '.join([f'({pt[0]:.2f}, {pt[1]:.2f})' for pt in rotated_class_0_bbox])
                    f.write(f"Rotated Class 0 B-BOX: {rotated_bbox_str}, Rotation Angle: {class_0_rotation_angle:.2f} degrees\n")

                f.write(f"Applied Rotation Angle for {image_name}: {rotation_angle:.2f} degrees\n")
                f.write(f"Original Image Size: {original_image_width}x{original_image_height}\n")
                f.write(f"Rotated Image Size: {rotated_image_width}x{rotated_image_height}\n")
                bbox_size_change_ratio = rotated_bbox_area_sum / original_bbox_area_sum if original_bbox_area_sum != 0 else 0
                f.write(f"B-BOX Size Change Ratio: {bbox_size_change_ratio:.2f}\n")

            else:
                f.write("No OBB detected.\n")

            f.write("\n")

    print(f"Test results saved to: {results_folder}")
    print(f"Bounding boxes saved to: {bbox_results_path}")

# 테스트 실행
test_model()
