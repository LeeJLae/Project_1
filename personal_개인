from ultralytics import YOLO
import os
import cv2
import numpy as np

# 절대 경로로 WEIGHTS_PATH 정의
WEIGHTS_PATH = "/home/jovyan/data-vol-1/Result/YOLO/1STEP_yolov11m/1STEP_yolov11m.pt"

# 모델 테스트 함수
def test_model():
    # 테스트 이미지 및 정답 레이블 폴더 경로 설정
    test_image_folder = '/home/jovyan/data-vol-1/dataset/test/images_test'
    output_dir = '/home/jovyan/data-vol-1/Result/DataPre/mode_1_rotation/Rotation_Counts'
     
    results_folder = os.path.join(output_dir, '1STEP_YOLO_result')
    os.makedirs(results_folder, exist_ok=True)  # 결과 폴더가 없으면 생성

    # YOLO 모델 로드
    model = YOLO(WEIGHTS_PATH)

    # 모델 예측
    results = model.predict(
        source=test_image_folder,  # 테스트할 이미지 폴더 경로
        save=True,                 # 결과 이미지를 저장
        project=results_folder,    # 저장할 기본 디렉토리
        name="1STEP_YOLO_result"   # 결과를 저장할 하위 폴더 이름
    )

    # 클래스별 OBB 위치와 회전 각도를 저장할 TXT 파일 경로 설정
    bbox_results_path = os.path.join(results_folder, 'bounding_boxes_with_rotation.txt')
    with open(bbox_results_path, 'w') as f:
        for result in results:
            image_name = os.path.basename(result.path)  # 이미지 이름
            image = cv2.imread(result.path)
            image_height, image_width = image.shape[:2]  # 이미지 사이즈
            rotation_angles = []  # 모든 클래스에 대한 회전 각도 리스트

            f.write(f"Image: {image_name}, Size: ({image_width}x{image_height})\n")  # 이미지 이름과 사이즈 기록
            
            # 예측된 OBB 정보 처리
            if result.obb is not None:
                class_ids = result.obb.cls  # 클래스 ID 가져오기
                obb_coordinates = result.obb.xyxyxyxy  # OBB 좌표 정보

                # 각 클래스에 대해 모든 OBB 좌표를 반복하여 기록
                for i in range(len(class_ids)):
                    cls = int(class_ids[i].item())  # 클래스 ID 가져오기
                    points = obb_coordinates[i].cpu().numpy()  # GPU 텐서를 CPU로 옮긴 후 numpy로 변환

                    # 좌하단과 우하단 좌표 추출
                    bottom_left = points[0]
                    bottom_right = points[1]

                    # 두 점 사이의 각도를 -90도 ~ 90도 범위로 계산
                    angle = np.degrees(np.arctan2(bottom_right[1] - bottom_left[1],
                                                  bottom_right[0] - bottom_left[0]))
                    if angle > 90:
                        angle -= 180  # 90도 초과 시 -90도 ~ 90도로 조정
                    elif angle < -90:
                        angle += 180  # -90도 미만 시 -90도로 조정
                    
                    # 가장 작은 절대값의 각도를 기준으로 회전 방향 설정
                    if angle < 0:
                        rotation_direction = "clockwise"  # 시계 방향 회전
                        rotation_angle = abs(angle)  # 절대값으로 변환
                    else:
                        rotation_direction = "counterclockwise"  # 반시계 방향 회전
                        rotation_angle = angle  # 양의 각도 그대로 사용

                    # 클래스 CA와 CB만 우선 고려하여 각도 추가
                    if cls in [1, 5]:  # 1이 CA, 5가 CB
                        rotation_angles.append((rotation_angle, rotation_direction, cls))

                    # 좌표를 문자열로 변환
                    points_str = ', '.join([f'({points[j][0]}, {points[j][1]})' for j in range(len(points))])
                    f.write(f'Class: {cls}, OBB Points: {points_str}, Rotation Angle: {rotation_angle:.2f} degrees, Direction: {rotation_direction}\n')
                    
            else:
                f.write("No OBB detected.\n")  # 감지된 OBB가 없는 경우 기록

            # 클래스 우선순위에 따라 가중치 적용하여 평균 회전 각도 계산
            if rotation_angles:
                weighted_angles = []
                for angle, direction, cls in rotation_angles:
                    if cls == 1:  # CA
                        weighted_angles.extend([angle] * 3)  # 클래스 CA의 가중치 3배
                    elif cls == 5:  # CB
                        weighted_angles.extend([angle] * 2)  # 클래스 CB의 가중치 2배

                avg_angle = np.mean(weighted_angles)
                f.write(f"Average Rotation Angle: {avg_angle:.2f} degrees\n")
                
                # 이미지 회전 적용 (시계 방향 또는 반시계 방향)
                if rotation_direction == "clockwise":
                    rotation_matrix = cv2.getRotationMatrix2D((image_width // 2, image_height // 2), -avg_angle, 1.0)
                else:
                    rotation_matrix = cv2.getRotationMatrix2D((image_width // 2, image_height // 2), avg_angle, 1.0)

                rotated_image = cv2.warpAffine(image, rotation_matrix, (image_width, image_height))

                # 회전된 이미지 저장
                rotated_image_path = os.path.join(results_folder, f"rotated_{image_name}")
                cv2.imwrite(rotated_image_path, rotated_image)
                print(f"Rotated image saved to: {rotated_image_path}")
                
            f.write("\n")  # 각 이미지 블록 사이에 줄 추가

    print(f"Test results saved to: {results_folder}")
    print(f"Bounding boxes with rotation saved to: {bbox_results_path}")

# 테스트 실행
test_model()
